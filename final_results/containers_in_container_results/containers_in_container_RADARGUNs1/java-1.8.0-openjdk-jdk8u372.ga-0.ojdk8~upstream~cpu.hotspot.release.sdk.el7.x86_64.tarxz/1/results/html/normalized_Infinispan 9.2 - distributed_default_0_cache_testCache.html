<html>
<head>
   <title>Normalized configuration cache_testCache for Infinispan 9.2 - distributed, group default on Cluster[default=1]</title>
   <link rel="stylesheet" href="style.css">
</head>

<body>
   <table>
      <tr>
         <th></th>
            <th class="center">
               Slave 0
            </th>
      </tr>

         <tr>
               <th class="left"> attributeDefinitionSet </th>
                  <td>Configuration = [simpleCache=false]</td>
         </tr>
         <tr>
               <th class="left"> attributes </th>
                  <td>Configuration = [simpleCache=false]</td>
         </tr>
         <tr>
               <th class="left"> clustering.attributes </th>
                  <td>ClusteringConfiguration = [cacheMode=DIST_SYNC, remoteTimeout=60000, invalidationBatchSize=128, biasAcquisition=ON_WRITE, biasLifespan=300000]</td>
         </tr>
         <tr>
               <th class="left"> clustering.biasAcquisition </th>
                  <td>ON_WRITE</td>
         </tr>
         <tr>
               <th class="left"> clustering.biasLifespan </th>
                  <td>300000</td>
         </tr>
         <tr>
               <th class="left"> clustering.cacheMode </th>
                  <td>DIST_SYNC</td>
         </tr>
         <tr>
               <th class="left"> clustering.cacheModeString </th>
                  <td>DIST_SYNC</td>
         </tr>
         <tr>
               <th class="left"> clustering.hash.attributes </th>
                  <td>HashConfiguration = [consistentHashFactory=null, hash=MurmurHash3, numOwners=2, numSegments=512, capacityFactor=1.0, keyPartitioner=HashFunctionPartitioner{hashFunction=MurmurHash3, ns=512}]</td>
         </tr>
         <tr>
               <th class="left"> clustering.hash.capacityFactor </th>
                  <td>1.0</td>
         </tr>
         <tr>
               <th class="left"> clustering.hash.consistentHashFactory </th>
                  <td>null</td>
         </tr>
         <tr>
               <th class="left"> clustering.hash.groups.attributes </th>
                  <td>GroupsConfiguration = [enabled=false, groupers=[]]</td>
         </tr>
         <tr>
               <th class="left"> clustering.hash.groups.enabled </th>
                  <td>false</td>
         </tr>
         <tr>
               <th class="left"> clustering.hash.keyPartitioner </th>
                  <td>HashFunctionPartitioner{hashFunction=MurmurHash3, ns=512}</td>
         </tr>
         <tr>
               <th class="left"> clustering.hash.numOwners </th>
                  <td>2</td>
         </tr>
         <tr>
               <th class="left"> clustering.hash.numSegments </th>
                  <td>512</td>
         </tr>
         <tr>
               <th class="left"> clustering.invalidationBatchSize </th>
                  <td>128</td>
         </tr>
         <tr>
               <th class="left"> clustering.l1.attributes </th>
                  <td>L1Configuration = [enabled=false, invalidationThreshold=0, lifespan=600000, cleanupTaskFrequency=60000]</td>
         </tr>
         <tr>
               <th class="left"> clustering.l1.cleanupTaskFrequency </th>
                  <td>60000</td>
         </tr>
         <tr>
               <th class="left"> clustering.l1.enabled </th>
                  <td>false</td>
         </tr>
         <tr>
               <th class="left"> clustering.l1.invalidationThreshold </th>
                  <td>0</td>
         </tr>
         <tr>
               <th class="left"> clustering.l1.lifespan </th>
                  <td>600000</td>
         </tr>
         <tr>
               <th class="left"> clustering.partitionHandling.attributes </th>
                  <td>PartitionHandlingConfiguration = [enabled=false, whenSplit=ALLOW_READ_WRITES, mergePolicy=PREFERRED_ALWAYS]</td>
         </tr>
         <tr>
               <th class="left"> clustering.partitionHandling.mergePolicy </th>
                  <td>PREFERRED_ALWAYS</td>
         </tr>
         <tr>
               <th class="left"> clustering.partitionHandling.resolveConflictsOnMerge </th>
                  <td>true</td>
         </tr>
         <tr>
               <th class="left"> clustering.partitionHandling.whenSplit </th>
                  <td>ALLOW_READ_WRITES</td>
         </tr>
         <tr>
               <th class="left"> clustering.remoteTimeout </th>
                  <td>60000</td>
         </tr>
         <tr>
               <th class="left"> clustering.stateTransfer.attributes </th>
                  <td>StoreAsBinaryConfiguration = [fetchInMemoryState=true, timeout=60000, chunkSize=512, awaitInitialTransfer=true]</td>
         </tr>
         <tr>
               <th class="left"> clustering.stateTransfer.awaitInitialTransfer </th>
                  <td>true</td>
         </tr>
         <tr>
               <th class="left"> clustering.stateTransfer.chunkSize </th>
                  <td>512</td>
         </tr>
         <tr>
               <th class="left"> clustering.stateTransfer.fetchInMemoryState </th>
                  <td>true</td>
         </tr>
         <tr>
               <th class="left"> clustering.stateTransfer.timeout </th>
                  <td>60000</td>
         </tr>
         <tr>
               <th class="left"> compatibility.attributes </th>
                  <td>CompatibilityModeConfiguration = [enabled=false, marshaller=null]</td>
         </tr>
         <tr>
               <th class="left"> compatibility.enabled </th>
                  <td>false</td>
         </tr>
         <tr>
               <th class="left"> compatibility.marshaller </th>
                  <td>null</td>
         </tr>
         <tr>
               <th class="left"> dataContainer.attributeDefinitionSet </th>
                  <td>DataContainerConfiguration = [properties={}, dataContainer=null]</td>
         </tr>
         <tr>
               <th class="left"> dataContainer.attributeSet </th>
                  <td>AbstractTypedPropertiesConfiguration = [properties={}]</td>
         </tr>
         <tr>
               <th class="left"> dataContainer.attributes </th>
                  <td>DataContainerConfiguration = [properties={}, dataContainer=null]</td>
         </tr>
         <tr>
               <th class="left"> dataContainer.properties </th>
                  <td>{}</td>
         </tr>
         <tr>
               <th class="left"> encoding.keyDataType.attributeDefinitionSet </th>
                  <td>ContentTypeConfiguration = [media-type=null]</td>
         </tr>
         <tr>
               <th class="left"> encoding.keyDataType.attributes </th>
                  <td>ContentTypeConfiguration = [media-type=null]</td>
         </tr>
         <tr>
               <th class="left"> encoding.keyDataType.isEncodingChanged </th>
                  <td>false</td>
         </tr>
         <tr>
               <th class="left"> encoding.keyDataType.isMediaTypeChanged </th>
                  <td>false</td>
         </tr>
         <tr>
               <th class="left"> encoding.keyDataType.mediaType </th>
                  <td>null</td>
         </tr>
         <tr>
               <th class="left"> encoding.valueDataType.attributeDefinitionSet </th>
                  <td>ContentTypeConfiguration = [media-type=null]</td>
         </tr>
         <tr>
               <th class="left"> encoding.valueDataType.attributes </th>
                  <td>ContentTypeConfiguration = [media-type=null]</td>
         </tr>
         <tr>
               <th class="left"> encoding.valueDataType.isEncodingChanged </th>
                  <td>false</td>
         </tr>
         <tr>
               <th class="left"> encoding.valueDataType.isMediaTypeChanged </th>
                  <td>false</td>
         </tr>
         <tr>
               <th class="left"> encoding.valueDataType.mediaType </th>
                  <td>null</td>
         </tr>
         <tr>
               <th class="left"> expiration.attributes </th>
                  <td>ExpirationConfiguration = [lifespan=-1, maxIdle=-1, reaperEnabled=true, wakeUpInterval=60000]</td>
         </tr>
         <tr>
               <th class="left"> expiration.lifespan </th>
                  <td>-1</td>
         </tr>
         <tr>
               <th class="left"> expiration.maxIdle </th>
                  <td>-1</td>
         </tr>
         <tr>
               <th class="left"> expiration.reaperEnabled </th>
                  <td>true</td>
         </tr>
         <tr>
               <th class="left"> expiration.wakeUpInterval </th>
                  <td>60000</td>
         </tr>
         <tr>
               <th class="left"> indexing.attributeSet </th>
                  <td>AbstractTypedPropertiesConfiguration = [properties={}]</td>
         </tr>
         <tr>
               <th class="left"> indexing.attributes </th>
                  <td>IndexingConfiguration = [properties={}, index=NONE, autoConfig=false, indexed-entities=[]]</td>
         </tr>
         <tr>
               <th class="left"> indexing.autoConfig </th>
                  <td>false</td>
         </tr>
         <tr>
               <th class="left"> indexing.index </th>
                  <td>NONE</td>
         </tr>
         <tr>
               <th class="left"> indexing.indexShareable </th>
                  <td>true</td>
         </tr>
         <tr>
               <th class="left"> indexing.properties </th>
                  <td>{}</td>
         </tr>
         <tr>
               <th class="left"> invocationBatching.attributes </th>
                  <td>InvocationBatchingConfiguration = [enabled=false]</td>
         </tr>
         <tr>
               <th class="left"> invocationBatching.enabled </th>
                  <td>false</td>
         </tr>
         <tr>
               <th class="left"> isTemplate </th>
                  <td>false</td>
         </tr>
         <tr>
               <th class="left"> jmxStatistics.attributes </th>
                  <td>JMXStatisticsConfiguration = [enabled=true, available=true]</td>
         </tr>
         <tr>
               <th class="left"> jmxStatistics.available </th>
                  <td>true</td>
         </tr>
         <tr>
               <th class="left"> jmxStatistics.enabled </th>
                  <td>true</td>
         </tr>
         <tr>
               <th class="left"> locking.attributes </th>
                  <td>LockingConfiguration = [concurrencyLevel=1000, isolationLevel=REPEATABLE_READ, lockAcquisitionTimeout=3000, striping=false, writeSkewCheck=true]</td>
         </tr>
         <tr>
               <th class="left"> locking.concurrencyLevel </th>
                  <td>1000</td>
         </tr>
         <tr>
               <th class="left"> locking.isolationLevel </th>
                  <td>REPEATABLE_READ</td>
         </tr>
         <tr>
               <th class="left"> locking.lockAcquisitionTimeout </th>
                  <td>3000</td>
         </tr>
         <tr>
               <th class="left"> locking.useLockStriping </th>
                  <td>false</td>
         </tr>
         <tr>
               <th class="left"> memory.addressCount </th>
                  <td>1048576</td>
         </tr>
         <tr>
               <th class="left"> memory.attributeDefinitionSet </th>
                  <td>MemoryConfiguration = [properties={}, storage=OBJECT, size=-1, type=COUNT, strategy=NONE, address-count=1048576]</td>
         </tr>
         <tr>
               <th class="left"> memory.attributes </th>
                  <td>MemoryConfiguration = [properties={}, storage=OBJECT, size=-1, type=COUNT, strategy=NONE, address-count=1048576]</td>
         </tr>
         <tr>
               <th class="left"> memory.evictionStrategy </th>
                  <td>NONE</td>
         </tr>
         <tr>
               <th class="left"> memory.evictionType </th>
                  <td>COUNT</td>
         </tr>
         <tr>
               <th class="left"> memory.isEvictionEnabled </th>
                  <td>false</td>
         </tr>
         <tr>
               <th class="left"> memory.size </th>
                  <td>-1</td>
         </tr>
         <tr>
               <th class="left"> memory.storageType </th>
                  <td>OBJECT</td>
         </tr>
         <tr>
               <th class="left"> modules </th>
                  <td>{}</td>
         </tr>
         <tr>
               <th class="left"> persistence.attributes </th>
                  <td>PersistenceConfiguration = [passivation=false]</td>
         </tr>
         <tr>
               <th class="left"> persistence.fetchPersistentState </th>
                  <td>false</td>
         </tr>
         <tr>
               <th class="left"> persistence.passivation </th>
                  <td>false</td>
         </tr>
         <tr>
               <th class="left"> persistence.preload </th>
                  <td>false</td>
         </tr>
         <tr>
               <th class="left"> persistence.usingAsyncStore </th>
                  <td>false</td>
         </tr>
         <tr>
               <th class="left"> persistence.usingStores </th>
                  <td>false</td>
         </tr>
         <tr>
               <th class="left"> security.authorization.attributes </th>
                  <td>AuthorizationConfiguration = [enabled=false, roles=[]]</td>
         </tr>
         <tr>
               <th class="left"> security.authorization.enabled </th>
                  <td>false</td>
         </tr>
         <tr>
               <th class="left"> simpleCache </th>
                  <td>false</td>
         </tr>
         <tr>
               <th class="left"> sites.attributes </th>
                  <td>SitesConfiguration = [disable=false, backup-sites-in-use=[]]</td>
         </tr>
         <tr>
               <th class="left"> sites.backupFor.attributes </th>
                  <td>BackupForConfiguration = [remoteCache=null, remoteSite=null]</td>
         </tr>
         <tr>
               <th class="left"> sites.backupFor.remoteCache </th>
                  <td>null</td>
         </tr>
         <tr>
               <th class="left"> sites.backupFor.remoteSite </th>
                  <td>null</td>
         </tr>
         <tr>
               <th class="left"> sites.disableBackups </th>
                  <td>false</td>
         </tr>
         <tr>
               <th class="left"> sites.hasEnabledBackups </th>
                  <td>false</td>
         </tr>
         <tr>
               <th class="left"> toXMLString </th>
                  <td><?xml version="1.0" ?>

<infinispan>
    <cache-container>
        <distributed-cache owners="2" segments="512" mode="SYNC" remote-timeout="60000" name="configuration" statistics="true">
            <locking concurrency-level="1000" acquire-timeout="3000"/>
            <transaction mode="NONE"/>
            <state-transfer timeout="60000"/>
        </distributed-cache>
    </cache-container></infinispan></td>
         </tr>
         <tr>
               <th class="left"> transaction.attributes </th>
                  <td>TransactionConfiguration = [auto-commit=true, stop-timeout=30000, locking=OPTIMISTIC, transaction-manager-lookup=org.infinispan.transaction.lookup.GenericTransactionManagerLookup@1eeaa6ed, transaction-synchronization-registry-lookup=null, mode=NON_TRANSACTIONAL, synchronization=false, single-phase-auto-commit=false, reaper-wake-up-interval=30000, complete-timeout=60000, transaction-protocol=DEFAULT, notifications=true]</td>
         </tr>
         <tr>
               <th class="left"> transaction.autoCommit </th>
                  <td>true</td>
         </tr>
         <tr>
               <th class="left"> transaction.cacheStopTimeout </th>
                  <td>30000</td>
         </tr>
         <tr>
               <th class="left"> transaction.completedTxTimeout </th>
                  <td>60000</td>
         </tr>
         <tr>
               <th class="left"> transaction.lockingMode </th>
                  <td>OPTIMISTIC</td>
         </tr>
         <tr>
               <th class="left"> transaction.notifications </th>
                  <td>true</td>
         </tr>
         <tr>
               <th class="left"> transaction.reaperWakeUpInterval </th>
                  <td>30000</td>
         </tr>
         <tr>
               <th class="left"> transaction.recovery.attributes </th>
                  <td>RecoveryConfiguration = [enabled=false, recoveryInfoCacheName=__recoveryInfoCacheName__]</td>
         </tr>
         <tr>
               <th class="left"> transaction.recovery.enabled </th>
                  <td>false</td>
         </tr>
         <tr>
               <th class="left"> transaction.recovery.recoveryInfoCacheName </th>
                  <td>__recoveryInfoCacheName__</td>
         </tr>
         <tr>
               <th class="left"> transaction.transactionManagerLookup </th>
                  <td>org.infinispan.transaction.lookup.GenericTransactionManagerLookup</td>
         </tr>
         <tr>
               <th class="left"> transaction.transactionMode </th>
                  <td>NON_TRANSACTIONAL</td>
         </tr>
         <tr>
               <th class="left"> transaction.transactionProtocol </th>
                  <td>DEFAULT</td>
         </tr>
         <tr>
               <th class="left"> transaction.transactionSynchronizationRegistryLookup </th>
                  <td>null</td>
         </tr>
         <tr>
               <th class="left"> transaction.use1PcForAutoCommitTransactions </th>
                  <td>false</td>
         </tr>
         <tr>
               <th class="left"> transaction.useSynchronization </th>
                  <td>false</td>
         </tr>
         <tr>
               <th class="left"> unsafe.attributes </th>
                  <td>UnsafeConfiguration = [unreliable-return-values=false]</td>
         </tr>
         <tr>
               <th class="left"> unsafe.unreliableReturnValues </th>
                  <td>false</td>
         </tr>
   </table>
</body>
</html>

